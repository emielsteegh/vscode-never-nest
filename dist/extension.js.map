{"version":3,"file":"extension.js","mappings":"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","sources":[".././src/config.ts",".././src/decorator.ts",".././src/extension.ts","../external commonjs \"vscode\"","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\n\nconst NEVER_NEST = 'neverNest';\n\n// safe way to get config values\nexport function config(key: string) {\n    const configuration = vscode.workspace.getConfiguration(NEVER_NEST);\n    if (!configuration || configuration === undefined) {\n        throw new Error('Could not get configuration');\n    }\n    if (!Object.keys(configuration).includes(key)) {\n        throw new Error(`Configuration key \"${key}\" does not exist.\n\t\tShould be defined in package.json.\n\t\tCurrent keys: [${Object.keys(vscode.workspace.getConfiguration(NEVER_NEST))}]`);\n\n    }\n\n    return configuration.get(key);\n}","import * as vscode from 'vscode';\nimport { config } from './config';\n\n\nconst HOVER_EXPLANATION = `Indent depth violation, please reduce nesting level.\n\n- Extract code into new functions.\n- Return early instead of nesting statements.\n- Use higher order functions.`;\n\n// Add listener for dark/lightmode change. This way we\n// dont have to check the theme every time the\n// decorations are updated.\nlet vscodeThemeKind = vscode.window.activeColorTheme.kind;\nvscode.window.onDidChangeActiveColorTheme(e => {\n    vscodeThemeKind = e.kind;\n});\n\n\n// returns the decoration type as described by the config\n// the settings used here are: colorLight, colorDark, violationStyle\nexport function getDecorationType() {\n    const violationColor = (vscodeThemeKind === 1 ? config(\"colorLight\") : config(\"colorDark\")) as string;\n\n    let violationDecorationType: vscode.TextEditorDecorationType;\n\n    if (config(\"violationStyle\") === 'separator') {\n        violationDecorationType = vscode.window.createTextEditorDecorationType({\n            borderStyle: \"solid\",\n            borderWidth: `0 0 0 1px`,\n            borderColor: violationColor as string\n        });\n    } else {\n        violationDecorationType = vscode.window.createTextEditorDecorationType({\n            backgroundColor: violationColor as string\n        });\n    }\n\n    return violationDecorationType;\n}\n\n// stores the decorations of all editors\nlet editorMap = new Map<vscode.TextEditor,\n    {\n        decorations: vscode.DecorationOptions[],\n        hovers: vscode.DecorationOptions[]\n    }>();\n\n// this decoration type is used for the violation decoration, it changes\nlet currentDecorationType = getDecorationType();\n// this decoration type is used for the hover message, it doesnt change\nlet hoverDecorationType = vscode.window.createTextEditorDecorationType({});\n\n// if the config of neverNest changes, reload old decorations, update the decoration type,\nvscode.workspace.onDidChangeConfiguration(e => {\n    if (e.affectsConfiguration('neverNest')) {\n        const newDecorationType = getDecorationType();\n        reloadDecorations(currentDecorationType, newDecorationType);\n        currentDecorationType = newDecorationType;\n    }\n});\n\nfunction getOrCreateEditorMapEntry(editor: vscode.TextEditor) {\n    if (!editorMap.has(editor)) {\n        editorMap.set(editor, { decorations: [], hovers: [] });\n    }\n    return editorMap.get(editor) as { decorations: vscode.DecorationOptions[], hovers: vscode.DecorationOptions[] };\n}\n\n// adds an object to the editors decorations array\nexport function addDecorationTo(editor: vscode.TextEditor, posStart: vscode.Position, posEnd: vscode.Position, tabSize: number) {\n    let { decorations, hovers } = getOrCreateEditorMapEntry(editor);\n\n    const violationRange = new vscode.Range(posStart, posEnd);\n    hovers.push({ range: violationRange, hoverMessage: HOVER_EXPLANATION });\n\n    if (config(\"violationStyle\") === 'separator') {\n        const violationChunks = divideRangeIntoChunks(violationRange, tabSize);\n        for (const chunkRange of violationChunks) {\n            let decoration = { range: chunkRange };\n            decorations.push(decoration);\n        }\n    } else {\n        const decoration = { range: violationRange };\n        decorations.push(decoration);\n    }\n}\n\n// empties the decorations array of the editor\nexport function clearDecorationsOf(editor: vscode.TextEditor) {\n    editorMap.set(editor, { decorations: [], hovers: [] });\n}\n\n// shows the objects to be decorated in the editor\nexport function showDecorationsOf(editor: vscode.TextEditor) {\n    let { decorations, hovers } = getOrCreateEditorMapEntry(editor);\n    editor.setDecorations(currentDecorationType, decorations);\n    editor.setDecorations(hoverDecorationType, hovers);\n}\n\n\n// loops through all editors that have decorations\n// cleans up old editors in the list\n// living ones get their decorations reloaded\nfunction reloadDecorations(oldDecorationType: vscode.TextEditorDecorationType, newDecorationType: vscode.TextEditorDecorationType): void {\n    const affectedEditors = editorMap.keys();\n\n    const affectedEditorsArray = Array.from(affectedEditors);\n    affectedEditorsArray.forEach(editor => {\n        if (!editor) {\n            editorMap.delete(editor);\n        } else if (editor === undefined) {\n            editorMap.delete(editor);\n        } else if (editor.document.isClosed) {\n            editorMap.delete(editor);\n        } else {\n            // collect decorationsArray from oldDecorationType\n            const { decorations } = getOrCreateEditorMapEntry(editor);\n            editor.setDecorations(oldDecorationType, []);\n            editor.setDecorations(newDecorationType, decorations);\n        }\n    });\n}\n\n// splits a range into chunks of size chunkSize\nfunction divideRangeIntoChunks(range: vscode.Range, chunkSize: number): vscode.Range[] {\n    const chunks: vscode.Range[] = [];\n    let start = range.start;\n    let end = range.end;\n\n    while (start.isBefore(end)) {\n        const chunkEnd = start.translate(0, chunkSize);\n        const chunk = new vscode.Range(start, chunkEnd.translate(0, -1));\n        chunks.push(chunk);\n        start = chunkEnd;\n    }\n\n    return chunks;\n}","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport { clearDecorationsOf, addDecorationTo, showDecorationsOf } from './decorator';\nimport { config } from './config';\n\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\tlet activeEditor = vscode.window.activeTextEditor;\n\n\t// Trigger on load\n\ttryTriggerUpdateDecorations(activeEditor);\n\n\t// Trigger update decorations when active text editor changes\n\tvscode.window.onDidChangeActiveTextEditor((editor: vscode.TextEditor | undefined) => {\n\t\tactiveEditor = editor;\n\t\ttryTriggerUpdateDecorations(activeEditor);\n\t}, null, context.subscriptions);\n\n\t// Trigger update decorations when document changes\n\tvscode.workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent) => {\n\t\ttryTriggerUpdateDecorations(activeEditor, event);\n\t}, null, context.subscriptions);\n\n}\n\n/**\n * Checks if the language of the current editor is included in the configuration.\n * @param editor - The active text editor\n * @returns true if the language is valid or false otherwise\n */\nfunction checkLanguageValid(editor: vscode.TextEditor) {\n\tconst includedLanguages = config(\"includedLanguages\") as string[];\n\tif (includedLanguages.length === 0) { return true; }\n\n\tconst currentLanguageId = editor.document.languageId;\n\tif (includedLanguages.includes(currentLanguageId)) { return true; }\n\n\treturn false;\n}\n\n\n/**\n * Attempts to trigger update decorations if conditions are met.\n * @param editor - The active text editor\n * @param event - The document change event (optional)\n */\nexport function tryTriggerUpdateDecorations(editor: vscode.TextEditor | undefined, event?: vscode.TextDocumentChangeEvent) {\n\tconsole.log(\"tryTriggerUpdateDecorations\");\n\n\tif (!editor) {\n\t\t// No editor\n\t\treturn;\n\t}\n\tif (!checkLanguageValid(editor)) {\n\t\t// Invalid language\n\t\treturn;\n\t}\n\tif (event && event.document !== editor.document) {\n\t\t// Event document not editor document\n\t\treturn;\n\t}\n\n\tupdateDecorations(editor);\n}\n\nfunction updateDecorations(editor: vscode.TextEditor) {\n\n\tvar documentText = editor.document.getText();\n\n\tconst tabSizeRaw = editor?.options.tabSize;\n\tlet tabSize: number;\n\tif (tabSizeRaw === undefined) { tabSize = 4; }\n\telse if (tabSizeRaw === \"auto\") { tabSize = 4; } // Optional, infer tab size from editor\n\telse { tabSize = +tabSizeRaw; }\n\n\tconst tabViolationDepth = config(\"maxTabDepth\") as number + 1;\n\tconst spaceViolationDepth = tabSize * tabViolationDepth;\n\n\tconst reViolation = new RegExp(`^(\\t{${tabViolationDepth},}| {${spaceViolationDepth},})`, \"gm\");\n\n\tlet match;\n\n\tclearDecorationsOf(editor);\n\twhile (match = reViolation.exec(documentText)) {\n\t\tconsole.log(match);\n\t\tconst posStart = editor.document.positionAt(match.index);\n\t\tconst posEnd = editor.document.positionAt(match.index + match[0].length);\n\t\taddDecorationTo(editor, posStart, posEnd, tabSize);\n\n\t}\n\tshowDecorationsOf(editor);\n}","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(937);\n"],"names":["NEVER_NEST","key","configuration","vscode","workspace","getConfiguration","undefined","Error","Object","keys","includes","get","vscodeThemeKind","window","activeColorTheme","kind","getDecorationType","violationColor","config","violationDecorationType","createTextEditorDecorationType","borderStyle","borderWidth","borderColor","backgroundColor","onDidChangeActiveColorTheme","e","editorMap","Map","currentDecorationType","hoverDecorationType","getOrCreateEditorMapEntry","editor","has","set","decorations","hovers","onDidChangeConfiguration","affectsConfiguration","newDecorationType","oldDecorationType","affectedEditors","Array","from","forEach","delete","document","isClosed","setDecorations","reloadDecorations","posStart","posEnd","tabSize","violationRange","Range","push","range","hoverMessage","violationChunks","chunkSize","chunks","start","end","isBefore","chunkEnd","translate","chunk","divideRangeIntoChunks","chunkRange","decoration","tryTriggerUpdateDecorations","event","console","log","includedLanguages","length","currentLanguageId","languageId","checkLanguageValid","documentText","getText","tabSizeRaw","options","tabViolationDepth","reViolation","RegExp","match","clearDecorationsOf","exec","positionAt","index","addDecorationTo","showDecorationsOf","updateDecorations","context","activeEditor","activeTextEditor","onDidChangeActiveTextEditor","subscriptions","onDidChangeTextDocument","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}